import { FontLoader } from 'three/addons';import { createTextFlow, updateFlows } from './orbitingText';import { consumeAccretionText } from './text';import {getDepthForDistance,getFontSizeForDistance,getMaterialForDistance,getOrbitSpeedForDistance,} from './gradientSystem';import { ACCRETION_WIDTH, BLACK_HOLE_RADIUS, WIDTH_SCALE_FACTOR } from '../quasarConfig';import { loading } from '../../loadingState';const loader = new FontLoader();export function addTextAccretionDisk(scene) {loader.load('/SourceCodePro.json', (font) => {let radius = BLACK_HOLE_RADIUS + 2;loading.blackHole.accretionDiskSize = ACCRETION_WIDTH - BLACK_HOLE_RADIUS;while (radius < ACCRETION_WIDTH * WIDTH_SCALE_FACTOR) {const fontSize = getFontSizeForDistance(radius);const text = consumeAccretionText(radius, fontSize);const material = getMaterialForDistance(radius);const orbitSpeed = getOrbitSpeedForDistance(radius);const depth = getDepthForDistance(radius);const flow = createTextFlow(scene, text, font, fontSize, material, radius, depth, orbitSpeed);radius += fontSize;loading.blackHole.accretionDiskDistanceLoaded += fontSize;const { object3D } = flow;object3D.frustumCulled = false;}});return updateFlows;}import { MeshBasicMaterial, Color } from 'three';import { depthGradient, fontSizeGradient, materialGradient, orbitSpeedGradient } from '../quasarConfig';/** * Finds the material from the gradient for an element at this distance. * @param distance * @return {MeshBasicMaterial} */export function getMaterialForDistance(distance) {return new MeshBasicMaterial(getInterpolatedValueFromDistance(distance, materialGradient, interpolateMaterialConfig));}export function getOrbitSpeedForDistance(distance) {return getInterpolatedValueFromDistance(distance, orbitSpeedGradient, lerp);}export function getFontSizeForDistance(distance) {return getInterpolatedValueFromDistance(distance, fontSizeGradient, lerp);}export function getDepthForDistance(distance) {return getInterpolatedValueFromDistance(distance, depthGradient, interpolateDepth);}/** * Interpolates between two material configurations. * @param mat1Config {object} * @param mat2Config {object} * @param alpha {number} between 0 and 1, closer to 0 returns a material config closer to mat1, closer to 1 is closer to mat2. */function interpolateMaterialConfig(mat1Config, mat2Config, alpha) {const color = new Color().lerpColors(new Color(mat1Config.color),new Color(mat2Config.color),alpha);const transparent = Boolean(mat2Config.opacity);const opacity = mat2Config.opacity || 0;return { color, transparent, opacity };}function interpolateDepth(depthConfig1, depthConfig2, alpha) {return lerp(depthConfig1.depth, depthConfig2.depth, alpha);}/** * Linearly interpolates a value for the provided distance, depending on the gradient. * @param distance * @param gradient an object with a 'lerp' function. * @param lerpFunc a function that takes in two values from the gradient and an alpha value. * @return {*} */function getInterpolatedValueFromDistance(distance, gradient, lerpFunc) {const { lowerBound, upperBound } = getGradientBoundariesFromDistance(distance, gradient);const lowerBoundValue = lowerBound.value;let alpha = invlerp(lowerBound.distance, upperBound.distance, distance);if (isNaN(alpha)) alpha = 0;if (lowerBoundValue.easeFunction) {alpha = lowerBoundValue.easeFunction(alpha);}return lerpFunc(lowerBoundValue, upperBound.value, alpha);}/** * Given some distance and a gradient, finds the closest upper and lower boundaries of a gradient at that point. * @param distance * @param gradient an object where the keys are numbers in ascending order. * @return {*} the lower and upper boundaries closest to the distance provided, with their values. */function getGradientBoundariesFromDistance(distance, gradient) {const distanceThresholds = Object.keys(gradient);let highestLowerDistance;let i = 0;for (; i < distanceThresholds.length; i++) {const distanceThreshold = distanceThresholds[i];if (distance < distanceThreshold) break;highestLowerDistance = distanceThreshold;}// If distance is lower than the lowest threshold, return the lowest threshold for both lower and upper boundariesif (highestLowerDistance === undefined) {return getBoundsWithValues(distanceThresholds[0], distanceThresholds[0], gradient);}// Get upper boundaryconst upperBound = distanceThresholds[i];// If the lower boundary is the highest boundary, return that for both upper and lowerif (upperBound === undefined) {return getBoundsWithValues(highestLowerDistance, highestLowerDistance, gradient);}return getBoundsWithValues(highestLowerDistance, upperBound, gradient);}function getBoundsWithValues(lowerBound, upperBound, gradient) {return {lowerBound: { distance: lowerBound, value: gradient[lowerBound] },upperBound: { distance: upperBound, value: gradient[upperBound] },};}// https://www.trysmudford.com/blog/linear-interpolation-functions/const lerp = (x, y, a) => x * (1 - a) + y * a;const clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a));const invlerp = (x, y, a) => clamp((a - x) / (y - x));import { TextGeometry } from 'three/addons';import * as THREE from 'three';import { Flow } from 'three/addons/modifiers/CurveModifier';const rad = deg => (deg * Math.PI) / 180.0;const flows = [];const baseRotationSpeed = 0.1;/** * Updates the positions of all generated disks. * @param delta the time since the last frame. */export function updateFlows(delta) {flows.forEach(flow => flow.moveAlongCurve(flow.orbitSpeed * delta));}const NUM_CIRCLE_POINTS = 16;const RIGHT_ANGLE_IN_RADIANS = rad(90);/** * Creates a circular text flow; this is a path that text follows. * @param scene * @param text {string} the text to show. * @param font {Font} a loaded font. * @param fontSize {number} the size of the font; this appears to be in scene units, not font px. * @param fontMaterial {MeshBasicMaterial} the material of the font. * @param radius {number} the distance from the centre the closest edge of the text should be. * @param fontDepth {number} the deep th e font is. * @param orbitSpeed {number} a fast text orbits around the black hole.. */export function createTextFlow(scene, text, font, fontSize, fontMaterial, radius, fontDepth = 1, orbitSpeed = baseRotationSpeed) {const geometry = new TextGeometry(text, {font: font,size: fontSize,depth: fontDepth,curveSegments: 3,});const textMesh = new THREE.Mesh(geometry, fontMaterial);geometry.rotateX(RIGHT_ANGLE_IN_RADIANS);geometry.translate(0, fontDepth / 2, 0);// Curve for pathconst curve = new THREE.CatmullRomCurve3(generateCirclePointPositions(NUM_CIRCLE_POINTS, radius));curve.curveType = 'centripetal';curve.closed = true;// Flow for movementconst flow = new Flow(textMesh);flow.orbitSpeed = orbitSpeed;flow.updateCurve(0, curve);scene.add(flow.object3D);flows.push(flow);return flow;}/** * Generates Vector3 positions in a circular pattern. * @param numPoints {number} how many points to generate. * @param radius {number} how far the points should be from the centre. * @return {THREE.Vector3[]} */function generateCirclePointPositions(numPoints, radius) {const pointPositions = [];const segmentAngle = 2 * Math.PI / numPoints;for (let i = 0; i < numPoints; i++) {pointPositions.push(new THREE.Vector3(radius * Math.cos(i * segmentAngle),0,radius * Math.sin(i * segmentAngle)),);}return pointPositions;}const accretionDiskText = await getAccretionDiskText('https://rwaw.githubusercontent.com/SimonsBrother/simonsbrother.github.io/refs/heads/main/src/3d/focus.js');let accretionTextProgress = 0;/** * Fetches text to put in the accretion disk. * @param path {string} the resource to fetch text from. * @return {Promise<string>} */async function getAccretionDiskText(path) {return await fetch(path).then(response => response.text()).then(text => text.replaceAll('', '')).catch(() => 'failed to load ---- '.repeat(100));}/** * Returns part of the accretion text, as much as fits in a given radius and font size. * @param radius the radius of the line of text from the centre. * @param fontSize the font size of the text. */export function consumeAccretionText(radius, fontSize) {const charsToExtract = calculateMaxTextLength(radius, fontSize);const textSlice = accretionDiskText.slice(accretionTextProgress, accretionTextProgress + charsToExtract);accretionTextProgress += charsToExtract;return textSlice;}const fontSizeToWidthRatio = 0.832;/** * Determines how many characters can fit in a ring of text, given the radius and font size. * @param radius {number} * @param fontSize {number} * @return {number} */function calculateMaxTextLength(radius, fontSize) {const totalDistance = 2 * Math.PI * radius;const fontWidth = fontSize * fontSizeToWidthRatio;return Math.floor(totalDistance / fontWidth);}import { WIDTH_SCALE_FACTOR } from '../quasarConfig';/** * Scales the middle values of the given gradient; the start should not be scaled, and the final is scaled separately. * @param gradient */function scaleGradientMiddleValues(gradient) {if (WIDTH_SCALE_FACTOR === 1) return;const distances = Object.keys(gradient);for (let i = 1; i < distances.length; i++) {const oldDistance = distances[i];const newDistance = Math.floor(distances[i] * WIDTH_SCALE_FACTOR);if (gradient[newDistance] !== undefined) console.warn(`Gradient distance ${newDistance} already used for ${gradient}`);// Replace keys as described here: https://stackoverflow.com/questions/4647817/javascript-object-rename-keyObject.defineProperty(gradient, newDistance,Object.getOwnPropertyDescriptor(gradient, oldDistance));delete gradient[oldDistance];}}export function postprocessGradient(gradent) {scaleGradientMiddleValues(gradent);}
